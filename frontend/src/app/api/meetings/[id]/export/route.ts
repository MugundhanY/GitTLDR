import { NextRequest, NextResponse } from 'next/server';

// Export meeting data to different formats
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: meetingId } = await params;
    
    // Get format from query params
    const { searchParams } = new URL(request.url);
    const format = searchParams.get('format') || 'pdf';
    
    // Mock meeting data - in real implementation, fetch from database
    const mockMeeting = {
      id: meetingId,
      title: 'Team Planning Meeting',
      summary: 'This meeting covered project planning, resource allocation, and upcoming milestones. The team discussed various topics including sprint goals, technical challenges, and timeline expectations.',
      createdAt: new Date().toISOString(),
      segments: [
        {
          id: '1',
          title: 'Project Overview',
          summary: 'Discussion about the current project status and upcoming deliverables.',
          text: 'We reviewed the current progress and identified key areas that need attention.',
          startTime: 0,
          endTime: 180
        },
        {
          id: '2',
          title: 'Resource Planning',
          summary: 'Planning for resource allocation and team assignments.',
          text: 'The team discussed resource requirements and planned upcoming assignments.',
          startTime: 180,
          endTime: 360
        }
      ]
    };

    if (format === 'json') {
      return NextResponse.json(mockMeeting);
    }

    // Generate structured text content for PDF/Word
    const content = `${mockMeeting.title}

Date: ${new Date(mockMeeting.createdAt).toLocaleDateString()}

SUMMARY
${mockMeeting.summary}

MEETING SEGMENTS
${mockMeeting.segments.map((segment, index) => `
${index + 1}. ${segment.title}
   Summary: ${segment.summary}
   ${segment.text ? `Transcript: ${segment.text}` : ''}
   Duration: ${Math.floor((segment.endTime - segment.startTime) / 60)} minutes
`).join('\n')}

---
Generated by GitTLDR Meeting System
`;

    // For now, return as plain text with proper headers for different formats
    let contentType = 'text/plain';
    let fileExtension = 'txt';
    let responseContent = content;
    
    if (format === 'pdf') {
      // Generate basic HTML that can be converted to PDF on client side
      const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${mockMeeting.title}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #333; border-bottom: 2px solid #007AFF; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        .segment { margin: 20px 0; padding: 15px; border-left: 4px solid #007AFF; background: #f8f9fa; }
        .meta { color: #666; font-size: 14px; }
        .timestamp { font-weight: bold; color: #007AFF; }
    </style>
</head>
<body>
    <h1>${mockMeeting.title}</h1>
    <div class="meta">
        <p><strong>Date:</strong> ${new Date(mockMeeting.createdAt).toLocaleDateString()}</p>
        <p><strong>Duration:</strong> ${Math.floor(mockMeeting.segments.reduce((total, seg) => total + (seg.endTime - seg.startTime), 0) / 60)} minutes</p>
    </div>
    
    <h2>Summary</h2>
    <p>${mockMeeting.summary}</p>
    
    <h2>Meeting Segments</h2>
    ${mockMeeting.segments.map((segment, index) => `
        <div class="segment">
            <h3>${index + 1}. ${segment.title}</h3>
            <p><span class="timestamp">Time:</span> ${Math.floor(segment.startTime / 60)}:${String(segment.startTime % 60).padStart(2, '0')} - ${Math.floor(segment.endTime / 60)}:${String(segment.endTime % 60).padStart(2, '0')}</p>
            <p><strong>Summary:</strong> ${segment.summary}</p>
            ${segment.text ? `<p><strong>Transcript:</strong> ${segment.text}</p>` : ''}
        </div>
    `).join('')}
    
    <hr style="margin-top: 40px;">
    <p class="meta">Generated by GitTLDR Meeting System on ${new Date().toLocaleDateString()}</p>
</body>
</html>`;
      contentType = 'text/html';
      fileExtension = 'html';
      responseContent = htmlContent;
    } else if (format === 'docx') {
      // Generate RTF (Rich Text Format) which is readable by Word
      const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}
\\f0\\fs24 ${mockMeeting.title}\\par
\\par
Date: ${new Date(mockMeeting.createdAt).toLocaleDateString()}\\par
Duration: ${Math.floor(mockMeeting.segments.reduce((total, seg) => total + (seg.endTime - seg.startTime), 0) / 60)} minutes\\par
\\par
\\b Summary\\b0\\par
${mockMeeting.summary}\\par
\\par
\\b Meeting Segments\\b0\\par
${mockMeeting.segments.map((segment, index) => `
\\par
${index + 1}. \\b ${segment.title}\\b0\\par
Time: ${Math.floor(segment.startTime / 60)}:${String(segment.startTime % 60).padStart(2, '0')} - ${Math.floor(segment.endTime / 60)}:${String(segment.endTime % 60).padStart(2, '0')}\\par
Summary: ${segment.summary}\\par
${segment.text ? `Transcript: ${segment.text}\\par` : ''}
`).join('')}
\\par
\\line
Generated by GitTLDR Meeting System on ${new Date().toLocaleDateString()}
}`;
      contentType = 'application/rtf';
      fileExtension = 'rtf';
      responseContent = rtfContent;
    } else if (format === 'json') {
      return NextResponse.json(mockMeeting);
    }

    const headers = {
      'Content-Type': contentType,
      'Content-Disposition': `attachment; filename="meeting-${meetingId}.${fileExtension}"`
    };

    return new NextResponse(responseContent, { headers });

  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json(
      { error: 'Failed to export meeting' },
      { status: 500 }
    );
  }
}
