generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String                    @id @default(cuid())
  email               String                    @unique
  name                String
  avatarUrl           String?                   @map("avatar_url")
  githubId            String                    @unique @map("github_id")
  githubLogin         String?                   @map("github_login")
  bio                 String?
  location            String?
  company             String?
  blog                String?
  twitterUsername     String?                   @map("twitter_username")
  publicRepos         Int?                      @map("public_repos")
  publicGists         Int?                      @map("public_gists")
  followers           Int?
  following           Int?
  hireable            Boolean?
  githubCreatedAt     DateTime?                 @map("github_created_at")
  credits             Int                       @default(150)
  createdAt           DateTime                  @default(now()) @map("created_at")
  updatedAt           DateTime                  @updatedAt @map("updated_at")
  githubAccessToken   String?                   @map("github_access_token")
  assignedActionItems MeetingActionItem[]       @relation("ActionItemAssignee")
  createdActionItems  MeetingActionItem[]
  meetingComments     MeetingComment[]
  meetingFavorites    MeetingFavorite[]
  meetingQAs          MeetingQA[]
  sharedMeetings      MeetingShareSetting[]     @relation("SharedMeetings")
  meetings            Meeting[]
  notifications       Notification[]            @relation("UserNotifications")
  uploadedAttachments QuestionAttachment[]      @relation("AttachmentUploadedBy")
  createdQuestions    Question[]                @relation("QuestionCreatedBy")
  repositories        Repository[]
  reviewedRequests    RepositoryAccessRequest[] @relation("ReviewedRequests")
  accessRequests      RepositoryAccessRequest[] @relation("AccessRequests")
  sharedRepositories  RepositoryShareSetting[]  @relation("SharedRepositories")
  transactions        Transaction[]
  issueFixes          IssueFix[]

  @@map("users")
}

model Repository {
  id                  String                    @id @default(cuid())
  name                String
  fullName            String                    @map("full_name")
  owner               String
  url                 String
  description         String?
  language            String?
  stars               Int                       @default(0)
  forks               Int                       @default(0)
  isPrivate           Boolean                   @default(false) @map("is_private")
  processed           Boolean                   @default(false)
  summary             String?
  embeddingStatus     RepositoryStatus          @default(PENDING) @map("embedding_status")
  hasWebhook          Boolean                   @default(false) @map("has_webhook")
  webhookId           String?                   @map("webhook_id")
  webhookUrl          String?                   @map("webhook_url")
  createdAt           DateTime                  @default(now()) @map("created_at")
  updatedAt           DateTime                  @updatedAt @map("updated_at")
  userId              String                    @map("user_id")
  avatarUrl           String?                   @map("avatar_url")
  fileCount           Int?                      @map("file_count")
  totalSize           Int?                      @map("total_size")
  watchersCount       Int?                      @map("watchers_count")
  meetings            Meeting[]
  questionAttachments QuestionAttachment[]
  questions           Question[]
  user                User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessRequests      RepositoryAccessRequest[]
  files               RepositoryFile[]
  shareSettings       RepositoryShareSetting[]
  issueFixes          IssueFix[]
  commits             Commit[]

  @@map("repositories")
}

model Commit {
  id           String       @id @default(cuid())
  repositoryId String       @map("repository_id")
  sha          String
  message      String
  timestamp    DateTime
  url          String
  authorName   String       @map("author_name")
  authorEmail  String       @map("author_email")
  authorAvatar String?      @map("author_avatar")
  filesChanged Int          @default(0) @map("files_changed")
  summary      String?
  status       CommitStatus @default(PENDING)
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")
  
  repository   Repository   @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  @@unique([repositoryId, sha])
  @@map("commits")
}

enum CommitStatus {
  PENDING
  COMPLETED
  FAILED
}

model RepositoryFile {
  id           String     @id @default(cuid())
  path         String
  name         String
  type         String
  size         Int
  summary      String?
  language     String?
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")
  repositoryId String     @map("repository_id")
  fileKey      String?    @map("file_key")
  fileUrl      String?    @map("file_url")
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)

  @@unique([repositoryId, path])
  @@map("repository_files")
}

model IssueFix {
  id              String         @id @default(cuid())
  repositoryId    String         @map("repository_id")
  userId          String         @map("user_id")
  issueNumber     Int            @map("issue_number")
  issueTitle      String         @map("issue_title")
  issueBody       String?        @map("issue_body")
  issueUrl        String         @map("issue_url")
  
  // Analysis Results
  analysis        Json?          // Issue understanding, root cause
  relevantFiles   Json?          @map("relevant_files") // Files to modify
  proposedFix     Json?          @map("proposed_fix") // Code changes (LEGACY: operations format)
  diff            String?        @db.Text // Unified diff patch (PRIMARY format)
  explanation     String?        // Human-readable explanation
  confidence      Float?         // AI confidence score (0-1)
  
  // Status Tracking
  status          IssueFixStatus @default(PENDING)
  errorMessage    String?        @map("error_message")
  
  // PR Information
  prNumber        Int?           @map("pr_number")
  prUrl           String?        @map("pr_url")
  prCreatedAt     DateTime?      @map("pr_created_at")
  
  // Metadata
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")
  completedAt     DateTime?      @map("completed_at")
  
  // Relations
  repository      Repository     @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([repositoryId, issueNumber])
  @@map("issue_fixes")
}

model Question {
  id                  String               @id @default(cuid())
  query               String
  answer              String
  confidenceScore     Float                @map("confidence_score")
  relevantFiles       Json                 @map("relevant_files")
  isFavorite          Boolean              @default(false) @map("is_favorite")
  tags                String[]             @default([])
  category            String?
  notes               String?
  attachments         Json                 @default("[]")
  toolExecutions      Json?                @map("tool_executions")
  githubDataUsed      Boolean              @default(false) @map("github_data_used")
  feedback            QuestionFeedback?
  feedbackAt          DateTime?            @map("feedback_at")
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  userId              String               @map("user_id")
  repositoryId        String               @map("repository_id")
  questionAttachments QuestionAttachment[]
  repository          Repository           @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  createdBy           User                 @relation("QuestionCreatedBy", fields: [userId], references: [id], onDelete: Cascade)

  @@map("questions")
}

model QuestionAttachment {
  id               String     @id @default(cuid())
  fileName         String     @map("file_name")
  originalFileName String     @map("original_file_name")
  fileSize         Int        @map("file_size")
  fileType         String     @map("file_type")
  uploadUrl        String     @map("upload_url")
  backblazeFileId  String?    @map("backblaze_file_id")
  createdAt        DateTime   @default(now()) @map("created_at")
  updatedAt        DateTime   @updatedAt @map("updated_at")
  uploadedBy       String     @map("uploaded_by")
  questionId       String?    @map("question_id")
  repositoryId     String     @map("repository_id")
  question         Question?  @relation(fields: [questionId], references: [id])
  repository       Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  uploadedByUser   User       @relation("AttachmentUploadedBy", fields: [uploadedBy], references: [id], onDelete: Cascade)

  @@map("question_attachments")
}

model Transaction {
  id          String          @id @default(cuid())
  type        TransactionType
  credits     Int
  amount      Float?
  description String
  stripeId    String?         @map("stripe_id")
  createdAt   DateTime        @default(now()) @map("created_at")
  userId      String          @map("user_id")
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("transactions")
}

model Meeting {
  id                  String                @id @default(uuid())
  title               String
  full_transcript     String?
  summary             String?
  status              MeetingStatus         @default(UPLOADED)
  created_at          DateTime              @default(now())
  updated_at          DateTime              @updatedAt
  source              String?
  language            String?
  raw_audio_path      String?
  num_segments        Int?
  participants        String[]
  userId              String?               @map("user_id")
  meeting_length      Float?
  user_edited_summary String?
  repositoryId        String?               @map("repository_id")
  actionItems         MeetingActionItem[]
  comments            MeetingComment[]
  favorites           MeetingFavorite[]
  qaItems             MeetingQA[]
  meeting_segments    MeetingSegment[]
  shareSettings       MeetingShareSetting[]
  repository          Repository?           @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  user                User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("meetings")
}

model MeetingSegment {
  id            String   @id @default(uuid())
  meeting_id    String
  segment_index Int
  title         String
  summary       String
  excerpt       String
  segment_text  String
  start_time    Float
  end_time      Float
  embedding     String?
  created_at    DateTime @default(now())
  meeting       Meeting  @relation(fields: [meeting_id], references: [id], onDelete: Cascade)

  @@unique([meeting_id, segment_index], name: "meeting_id_segment_index")
  @@map("meeting_segments")
}

model MeetingQA {
  id              String   @id @default(uuid())
  meetingId       String   @map("meeting_id")
  userId          String   @map("user_id")
  question        String
  answer          String
  confidence      Float?   @default(0.0)
  timestamp       Float?
  relatedSegments String[] @map("related_segments")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  meeting         Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("meeting_qa")
}

model MeetingFavorite {
  id        String   @id @default(uuid())
  meetingId String   @map("meeting_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now())
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([meetingId, userId])
  @@map("meeting_favorites")
}

model MeetingComment {
  id        String   @id @default(uuid())
  meetingId String   @map("meeting_id")
  userId    String   @map("user_id")
  text      String
  timestamp Float
  segmentId String?  @map("segment_id")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("meeting_comments")
}

model MeetingActionItem {
  id         String             @id @default(uuid())
  meetingId  String             @map("meeting_id")
  userId     String             @map("user_id")
  assigneeId String?            @map("assignee_id")
  text       String
  completed  Boolean            @default(false)
  priority   ActionItemPriority @default(MEDIUM)
  dueDate    DateTime?          @map("due_date")
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  assignee   User?              @relation("ActionItemAssignee", fields: [assigneeId], references: [id])
  meeting    Meeting            @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  creator    User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("meeting_action_items")
}

model MeetingShareSetting {
  id        String   @id @default(uuid())
  meetingId String   @map("meeting_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  meeting   Meeting  @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  user      User     @relation("SharedMeetings", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([meetingId, userId])
  @@map("meeting_share_settings")
}

model Notification {
  id         String           @id @default(uuid())
  userId     String           @map("user_id")
  type       NotificationType
  title      String
  message    String
  read       Boolean          @default(false)
  actionUrl  String?          @map("action_url")
  actionText String?          @map("action_text")
  metadata   Json?
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  user       User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model RepositoryShareSetting {
  id           String     @id @default(uuid())
  repositoryId String     @map("repository_id")
  userId       String     @map("user_id")
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  repository   Repository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  user         User       @relation("SharedRepositories", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([repositoryId, userId])
  @@map("repository_share_settings")
}

model RepositoryAccessRequest {
  id           String              @id @default(uuid())
  repositoryId String              @map("repository_id")
  userId       String              @map("user_id")
  message      String?
  status       AccessRequestStatus @default(PENDING)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  reviewedAt   DateTime?           @map("reviewed_at")
  reviewedBy   String?             @map("reviewed_by")
  repository   Repository          @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
  reviewer     User?               @relation("ReviewedRequests", fields: [reviewedBy], references: [id])
  user         User                @relation("AccessRequests", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([repositoryId, userId])
  @@map("repository_access_requests")
}

enum AccessRequestStatus {
  PENDING
  APPROVED
  DENIED
}

enum QuestionFeedback {
  LIKE
  DISLIKE
}

enum RepositoryStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum TransactionType {
  PURCHASE
  USAGE
}

enum MeetingStatus {
  UPLOADED
  PROCESSING
  COMPLETED
  FAILED
  TRANSCRIBING
  SUMMARIZING
}

enum ActionItemPriority {
  LOW
  MEDIUM
  HIGH
}

enum NotificationType {
  REPO_CREATED
  REPO_PROCESSED
  REPO_FAILED
  MEETING_UPLOADED
  MEETING_PROCESSED
  MEETING_FAILED
  CREDITS_LOW
  CREDITS_DEPLETED
  ACTION_ITEM_ASSIGNED
  ACTION_ITEM_COMPLETED
  COMMENT_ADDED
  MEETING_SHARED
  ACCESS_REQUEST_RECEIVED
  ACCESS_REQUEST_APPROVED
  ACCESS_REQUEST_DENIED
}

enum IssueFixStatus {
  PENDING
  ANALYZING
  RETRIEVING_CODE
  GENERATING_FIX
  VALIDATING
  READY_FOR_REVIEW
  NEEDS_CLARIFICATION
  CREATING_PR
  COMPLETED
  FAILED
  CANCELLED
}
